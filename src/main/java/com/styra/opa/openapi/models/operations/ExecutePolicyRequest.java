/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.styra.opa.openapi.models.operations;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import com.styra.opa.openapi.models.shared.Explain;
import com.styra.opa.openapi.models.shared.GzipAcceptEncoding;
import com.styra.opa.openapi.utils.LazySingletonValue;
import com.styra.opa.openapi.utils.SpeakeasyMetadata;
import com.styra.opa.openapi.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;


public class ExecutePolicyRequest {

    /**
     * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=path")
    private String path;

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=Accept-Encoding")
    private Optional<? extends GzipAcceptEncoding> acceptEncoding;

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=pretty")
    private Optional<Boolean> pretty;

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=provenance")
    private Optional<Boolean> provenance;

    /**
     * Return query explanation in addition to result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=explain")
    private Optional<? extends Explain> explain;

    /**
     * Return query performance metrics in addition to result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=metrics")
    private Optional<Boolean> metrics;

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=instrument")
    private Optional<Boolean> instrument;

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=strict-builtin-errors")
    private Optional<Boolean> strictBuiltinErrors;

    @JsonCreator
    public ExecutePolicyRequest(
            String path,
            Optional<? extends GzipAcceptEncoding> acceptEncoding,
            Optional<Boolean> pretty,
            Optional<Boolean> provenance,
            Optional<? extends Explain> explain,
            Optional<Boolean> metrics,
            Optional<Boolean> instrument,
            Optional<Boolean> strictBuiltinErrors) {
        Utils.checkNotNull(path, "path");
        Utils.checkNotNull(acceptEncoding, "acceptEncoding");
        Utils.checkNotNull(pretty, "pretty");
        Utils.checkNotNull(provenance, "provenance");
        Utils.checkNotNull(explain, "explain");
        Utils.checkNotNull(metrics, "metrics");
        Utils.checkNotNull(instrument, "instrument");
        Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
        this.path = path;
        this.acceptEncoding = acceptEncoding;
        this.pretty = pretty;
        this.provenance = provenance;
        this.explain = explain;
        this.metrics = metrics;
        this.instrument = instrument;
        this.strictBuiltinErrors = strictBuiltinErrors;
    }
    
    public ExecutePolicyRequest(
            String path) {
        this(path, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
     */
    @JsonIgnore
    public String path() {
        return path;
    }

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GzipAcceptEncoding> acceptEncoding() {
        return (Optional<GzipAcceptEncoding>) acceptEncoding;
    }

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    @JsonIgnore
    public Optional<Boolean> pretty() {
        return pretty;
    }

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    @JsonIgnore
    public Optional<Boolean> provenance() {
        return provenance;
    }

    /**
     * Return query explanation in addition to result.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Explain> explain() {
        return (Optional<Explain>) explain;
    }

    /**
     * Return query performance metrics in addition to result.
     */
    @JsonIgnore
    public Optional<Boolean> metrics() {
        return metrics;
    }

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    @JsonIgnore
    public Optional<Boolean> instrument() {
        return instrument;
    }

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    @JsonIgnore
    public Optional<Boolean> strictBuiltinErrors() {
        return strictBuiltinErrors;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
     */
    public ExecutePolicyRequest withPath(String path) {
        Utils.checkNotNull(path, "path");
        this.path = path;
        return this;
    }

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    public ExecutePolicyRequest withAcceptEncoding(GzipAcceptEncoding acceptEncoding) {
        Utils.checkNotNull(acceptEncoding, "acceptEncoding");
        this.acceptEncoding = Optional.ofNullable(acceptEncoding);
        return this;
    }

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    public ExecutePolicyRequest withAcceptEncoding(Optional<? extends GzipAcceptEncoding> acceptEncoding) {
        Utils.checkNotNull(acceptEncoding, "acceptEncoding");
        this.acceptEncoding = acceptEncoding;
        return this;
    }

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    public ExecutePolicyRequest withPretty(boolean pretty) {
        Utils.checkNotNull(pretty, "pretty");
        this.pretty = Optional.ofNullable(pretty);
        return this;
    }

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    public ExecutePolicyRequest withPretty(Optional<Boolean> pretty) {
        Utils.checkNotNull(pretty, "pretty");
        this.pretty = pretty;
        return this;
    }

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    public ExecutePolicyRequest withProvenance(boolean provenance) {
        Utils.checkNotNull(provenance, "provenance");
        this.provenance = Optional.ofNullable(provenance);
        return this;
    }

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    public ExecutePolicyRequest withProvenance(Optional<Boolean> provenance) {
        Utils.checkNotNull(provenance, "provenance");
        this.provenance = provenance;
        return this;
    }

    /**
     * Return query explanation in addition to result.
     */
    public ExecutePolicyRequest withExplain(Explain explain) {
        Utils.checkNotNull(explain, "explain");
        this.explain = Optional.ofNullable(explain);
        return this;
    }

    /**
     * Return query explanation in addition to result.
     */
    public ExecutePolicyRequest withExplain(Optional<? extends Explain> explain) {
        Utils.checkNotNull(explain, "explain");
        this.explain = explain;
        return this;
    }

    /**
     * Return query performance metrics in addition to result.
     */
    public ExecutePolicyRequest withMetrics(boolean metrics) {
        Utils.checkNotNull(metrics, "metrics");
        this.metrics = Optional.ofNullable(metrics);
        return this;
    }

    /**
     * Return query performance metrics in addition to result.
     */
    public ExecutePolicyRequest withMetrics(Optional<Boolean> metrics) {
        Utils.checkNotNull(metrics, "metrics");
        this.metrics = metrics;
        return this;
    }

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    public ExecutePolicyRequest withInstrument(boolean instrument) {
        Utils.checkNotNull(instrument, "instrument");
        this.instrument = Optional.ofNullable(instrument);
        return this;
    }

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    public ExecutePolicyRequest withInstrument(Optional<Boolean> instrument) {
        Utils.checkNotNull(instrument, "instrument");
        this.instrument = instrument;
        return this;
    }

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    public ExecutePolicyRequest withStrictBuiltinErrors(boolean strictBuiltinErrors) {
        Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
        this.strictBuiltinErrors = Optional.ofNullable(strictBuiltinErrors);
        return this;
    }

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    public ExecutePolicyRequest withStrictBuiltinErrors(Optional<Boolean> strictBuiltinErrors) {
        Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
        this.strictBuiltinErrors = strictBuiltinErrors;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ExecutePolicyRequest other = (ExecutePolicyRequest) o;
        return 
            Objects.deepEquals(this.path, other.path) &&
            Objects.deepEquals(this.acceptEncoding, other.acceptEncoding) &&
            Objects.deepEquals(this.pretty, other.pretty) &&
            Objects.deepEquals(this.provenance, other.provenance) &&
            Objects.deepEquals(this.explain, other.explain) &&
            Objects.deepEquals(this.metrics, other.metrics) &&
            Objects.deepEquals(this.instrument, other.instrument) &&
            Objects.deepEquals(this.strictBuiltinErrors, other.strictBuiltinErrors);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            path,
            acceptEncoding,
            pretty,
            provenance,
            explain,
            metrics,
            instrument,
            strictBuiltinErrors);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ExecutePolicyRequest.class,
                "path", path,
                "acceptEncoding", acceptEncoding,
                "pretty", pretty,
                "provenance", provenance,
                "explain", explain,
                "metrics", metrics,
                "instrument", instrument,
                "strictBuiltinErrors", strictBuiltinErrors);
    }
    
    public final static class Builder {
 
        private String path;
 
        private Optional<? extends GzipAcceptEncoding> acceptEncoding = Optional.empty();
 
        private Optional<Boolean> pretty = Optional.empty();
 
        private Optional<Boolean> provenance = Optional.empty();
 
        private Optional<? extends Explain> explain = Optional.empty();
 
        private Optional<Boolean> metrics = Optional.empty();
 
        private Optional<Boolean> instrument = Optional.empty();
 
        private Optional<Boolean> strictBuiltinErrors = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
         */
        public Builder path(String path) {
            Utils.checkNotNull(path, "path");
            this.path = path;
            return this;
        }

        /**
         * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
         */
        public Builder acceptEncoding(GzipAcceptEncoding acceptEncoding) {
            Utils.checkNotNull(acceptEncoding, "acceptEncoding");
            this.acceptEncoding = Optional.ofNullable(acceptEncoding);
            return this;
        }

        /**
         * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
         */
        public Builder acceptEncoding(Optional<? extends GzipAcceptEncoding> acceptEncoding) {
            Utils.checkNotNull(acceptEncoding, "acceptEncoding");
            this.acceptEncoding = acceptEncoding;
            return this;
        }

        /**
         * If parameter is `true`, response will formatted for humans.
         */
        public Builder pretty(boolean pretty) {
            Utils.checkNotNull(pretty, "pretty");
            this.pretty = Optional.ofNullable(pretty);
            return this;
        }

        /**
         * If parameter is `true`, response will formatted for humans.
         */
        public Builder pretty(Optional<Boolean> pretty) {
            Utils.checkNotNull(pretty, "pretty");
            this.pretty = pretty;
            return this;
        }

        /**
         * If parameter is true, response will include build/version info in addition to the result.
         */
        public Builder provenance(boolean provenance) {
            Utils.checkNotNull(provenance, "provenance");
            this.provenance = Optional.ofNullable(provenance);
            return this;
        }

        /**
         * If parameter is true, response will include build/version info in addition to the result.
         */
        public Builder provenance(Optional<Boolean> provenance) {
            Utils.checkNotNull(provenance, "provenance");
            this.provenance = provenance;
            return this;
        }

        /**
         * Return query explanation in addition to result.
         */
        public Builder explain(Explain explain) {
            Utils.checkNotNull(explain, "explain");
            this.explain = Optional.ofNullable(explain);
            return this;
        }

        /**
         * Return query explanation in addition to result.
         */
        public Builder explain(Optional<? extends Explain> explain) {
            Utils.checkNotNull(explain, "explain");
            this.explain = explain;
            return this;
        }

        /**
         * Return query performance metrics in addition to result.
         */
        public Builder metrics(boolean metrics) {
            Utils.checkNotNull(metrics, "metrics");
            this.metrics = Optional.ofNullable(metrics);
            return this;
        }

        /**
         * Return query performance metrics in addition to result.
         */
        public Builder metrics(Optional<Boolean> metrics) {
            Utils.checkNotNull(metrics, "metrics");
            this.metrics = metrics;
            return this;
        }

        /**
         * Instrument query evaluation and return a superset of performance metrics in addition to result.
         */
        public Builder instrument(boolean instrument) {
            Utils.checkNotNull(instrument, "instrument");
            this.instrument = Optional.ofNullable(instrument);
            return this;
        }

        /**
         * Instrument query evaluation and return a superset of performance metrics in addition to result.
         */
        public Builder instrument(Optional<Boolean> instrument) {
            Utils.checkNotNull(instrument, "instrument");
            this.instrument = instrument;
            return this;
        }

        /**
         * Treat built-in function call errors as fatal and return an error immediately.
         */
        public Builder strictBuiltinErrors(boolean strictBuiltinErrors) {
            Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
            this.strictBuiltinErrors = Optional.ofNullable(strictBuiltinErrors);
            return this;
        }

        /**
         * Treat built-in function call errors as fatal and return an error immediately.
         */
        public Builder strictBuiltinErrors(Optional<Boolean> strictBuiltinErrors) {
            Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
            this.strictBuiltinErrors = strictBuiltinErrors;
            return this;
        }
        
        public ExecutePolicyRequest build() {
            if (path == null) {
                path = _SINGLETON_VALUE_Path.value();
            }            return new ExecutePolicyRequest(
                path,
                acceptEncoding,
                pretty,
                provenance,
                explain,
                metrics,
                instrument,
                strictBuiltinErrors);
        }

        private static final LazySingletonValue<String> _SINGLETON_VALUE_Path =
                new LazySingletonValue<>(
                        "path",
                        "\"\"",
                        new TypeReference<String>() {});
    }
}

