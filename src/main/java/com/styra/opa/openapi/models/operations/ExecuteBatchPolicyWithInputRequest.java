/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.styra.opa.openapi.models.operations;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import com.styra.opa.openapi.models.shared.Explain;
import com.styra.opa.openapi.models.shared.GzipAcceptEncoding;
import com.styra.opa.openapi.models.shared.GzipContentEncoding;
import com.styra.opa.openapi.utils.LazySingletonValue;
import com.styra.opa.openapi.utils.SpeakeasyMetadata;
import com.styra.opa.openapi.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;


public class ExecuteBatchPolicyWithInputRequest {

    /**
     * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=path")
    private String path;

    /**
     * Indicates that the request body is gzip encoded
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=Content-Encoding")
    private Optional<? extends GzipContentEncoding> contentEncoding;

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=Accept-Encoding")
    private Optional<? extends GzipAcceptEncoding> acceptEncoding;

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=pretty")
    private Optional<Boolean> pretty;

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=provenance")
    private Optional<Boolean> provenance;

    /**
     * Return query explanation in addition to result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=explain")
    private Optional<? extends Explain> explain;

    /**
     * Return query performance metrics in addition to result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=metrics")
    private Optional<Boolean> metrics;

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=instrument")
    private Optional<Boolean> instrument;

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=strict-builtin-errors")
    private Optional<Boolean> strictBuiltinErrors;

    /**
     * The batch of inputs
     */
    @SpeakeasyMetadata("request:mediaType=application/json")
    private ExecuteBatchPolicyWithInputRequestBody requestBody;

    @JsonCreator
    public ExecuteBatchPolicyWithInputRequest(
            String path,
            Optional<? extends GzipContentEncoding> contentEncoding,
            Optional<? extends GzipAcceptEncoding> acceptEncoding,
            Optional<Boolean> pretty,
            Optional<Boolean> provenance,
            Optional<? extends Explain> explain,
            Optional<Boolean> metrics,
            Optional<Boolean> instrument,
            Optional<Boolean> strictBuiltinErrors,
            ExecuteBatchPolicyWithInputRequestBody requestBody) {
        Utils.checkNotNull(path, "path");
        Utils.checkNotNull(contentEncoding, "contentEncoding");
        Utils.checkNotNull(acceptEncoding, "acceptEncoding");
        Utils.checkNotNull(pretty, "pretty");
        Utils.checkNotNull(provenance, "provenance");
        Utils.checkNotNull(explain, "explain");
        Utils.checkNotNull(metrics, "metrics");
        Utils.checkNotNull(instrument, "instrument");
        Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
        Utils.checkNotNull(requestBody, "requestBody");
        this.path = path;
        this.contentEncoding = contentEncoding;
        this.acceptEncoding = acceptEncoding;
        this.pretty = pretty;
        this.provenance = provenance;
        this.explain = explain;
        this.metrics = metrics;
        this.instrument = instrument;
        this.strictBuiltinErrors = strictBuiltinErrors;
        this.requestBody = requestBody;
    }
    
    public ExecuteBatchPolicyWithInputRequest(
            String path,
            ExecuteBatchPolicyWithInputRequestBody requestBody) {
        this(path, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), requestBody);
    }

    /**
     * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
     */
    @JsonIgnore
    public String path() {
        return path;
    }

    /**
     * Indicates that the request body is gzip encoded
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GzipContentEncoding> contentEncoding() {
        return (Optional<GzipContentEncoding>) contentEncoding;
    }

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GzipAcceptEncoding> acceptEncoding() {
        return (Optional<GzipAcceptEncoding>) acceptEncoding;
    }

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    @JsonIgnore
    public Optional<Boolean> pretty() {
        return pretty;
    }

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    @JsonIgnore
    public Optional<Boolean> provenance() {
        return provenance;
    }

    /**
     * Return query explanation in addition to result.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Explain> explain() {
        return (Optional<Explain>) explain;
    }

    /**
     * Return query performance metrics in addition to result.
     */
    @JsonIgnore
    public Optional<Boolean> metrics() {
        return metrics;
    }

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    @JsonIgnore
    public Optional<Boolean> instrument() {
        return instrument;
    }

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    @JsonIgnore
    public Optional<Boolean> strictBuiltinErrors() {
        return strictBuiltinErrors;
    }

    /**
     * The batch of inputs
     */
    @JsonIgnore
    public ExecuteBatchPolicyWithInputRequestBody requestBody() {
        return requestBody;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
     */
    public ExecuteBatchPolicyWithInputRequest withPath(String path) {
        Utils.checkNotNull(path, "path");
        this.path = path;
        return this;
    }

    /**
     * Indicates that the request body is gzip encoded
     */
    public ExecuteBatchPolicyWithInputRequest withContentEncoding(GzipContentEncoding contentEncoding) {
        Utils.checkNotNull(contentEncoding, "contentEncoding");
        this.contentEncoding = Optional.ofNullable(contentEncoding);
        return this;
    }

    /**
     * Indicates that the request body is gzip encoded
     */
    public ExecuteBatchPolicyWithInputRequest withContentEncoding(Optional<? extends GzipContentEncoding> contentEncoding) {
        Utils.checkNotNull(contentEncoding, "contentEncoding");
        this.contentEncoding = contentEncoding;
        return this;
    }

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    public ExecuteBatchPolicyWithInputRequest withAcceptEncoding(GzipAcceptEncoding acceptEncoding) {
        Utils.checkNotNull(acceptEncoding, "acceptEncoding");
        this.acceptEncoding = Optional.ofNullable(acceptEncoding);
        return this;
    }

    /**
     * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
     */
    public ExecuteBatchPolicyWithInputRequest withAcceptEncoding(Optional<? extends GzipAcceptEncoding> acceptEncoding) {
        Utils.checkNotNull(acceptEncoding, "acceptEncoding");
        this.acceptEncoding = acceptEncoding;
        return this;
    }

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    public ExecuteBatchPolicyWithInputRequest withPretty(boolean pretty) {
        Utils.checkNotNull(pretty, "pretty");
        this.pretty = Optional.ofNullable(pretty);
        return this;
    }

    /**
     * If parameter is `true`, response will formatted for humans.
     */
    public ExecuteBatchPolicyWithInputRequest withPretty(Optional<Boolean> pretty) {
        Utils.checkNotNull(pretty, "pretty");
        this.pretty = pretty;
        return this;
    }

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    public ExecuteBatchPolicyWithInputRequest withProvenance(boolean provenance) {
        Utils.checkNotNull(provenance, "provenance");
        this.provenance = Optional.ofNullable(provenance);
        return this;
    }

    /**
     * If parameter is true, response will include build/version info in addition to the result.
     */
    public ExecuteBatchPolicyWithInputRequest withProvenance(Optional<Boolean> provenance) {
        Utils.checkNotNull(provenance, "provenance");
        this.provenance = provenance;
        return this;
    }

    /**
     * Return query explanation in addition to result.
     */
    public ExecuteBatchPolicyWithInputRequest withExplain(Explain explain) {
        Utils.checkNotNull(explain, "explain");
        this.explain = Optional.ofNullable(explain);
        return this;
    }

    /**
     * Return query explanation in addition to result.
     */
    public ExecuteBatchPolicyWithInputRequest withExplain(Optional<? extends Explain> explain) {
        Utils.checkNotNull(explain, "explain");
        this.explain = explain;
        return this;
    }

    /**
     * Return query performance metrics in addition to result.
     */
    public ExecuteBatchPolicyWithInputRequest withMetrics(boolean metrics) {
        Utils.checkNotNull(metrics, "metrics");
        this.metrics = Optional.ofNullable(metrics);
        return this;
    }

    /**
     * Return query performance metrics in addition to result.
     */
    public ExecuteBatchPolicyWithInputRequest withMetrics(Optional<Boolean> metrics) {
        Utils.checkNotNull(metrics, "metrics");
        this.metrics = metrics;
        return this;
    }

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    public ExecuteBatchPolicyWithInputRequest withInstrument(boolean instrument) {
        Utils.checkNotNull(instrument, "instrument");
        this.instrument = Optional.ofNullable(instrument);
        return this;
    }

    /**
     * Instrument query evaluation and return a superset of performance metrics in addition to result.
     */
    public ExecuteBatchPolicyWithInputRequest withInstrument(Optional<Boolean> instrument) {
        Utils.checkNotNull(instrument, "instrument");
        this.instrument = instrument;
        return this;
    }

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    public ExecuteBatchPolicyWithInputRequest withStrictBuiltinErrors(boolean strictBuiltinErrors) {
        Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
        this.strictBuiltinErrors = Optional.ofNullable(strictBuiltinErrors);
        return this;
    }

    /**
     * Treat built-in function call errors as fatal and return an error immediately.
     */
    public ExecuteBatchPolicyWithInputRequest withStrictBuiltinErrors(Optional<Boolean> strictBuiltinErrors) {
        Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
        this.strictBuiltinErrors = strictBuiltinErrors;
        return this;
    }

    /**
     * The batch of inputs
     */
    public ExecuteBatchPolicyWithInputRequest withRequestBody(ExecuteBatchPolicyWithInputRequestBody requestBody) {
        Utils.checkNotNull(requestBody, "requestBody");
        this.requestBody = requestBody;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ExecuteBatchPolicyWithInputRequest other = (ExecuteBatchPolicyWithInputRequest) o;
        return 
            Objects.deepEquals(this.path, other.path) &&
            Objects.deepEquals(this.contentEncoding, other.contentEncoding) &&
            Objects.deepEquals(this.acceptEncoding, other.acceptEncoding) &&
            Objects.deepEquals(this.pretty, other.pretty) &&
            Objects.deepEquals(this.provenance, other.provenance) &&
            Objects.deepEquals(this.explain, other.explain) &&
            Objects.deepEquals(this.metrics, other.metrics) &&
            Objects.deepEquals(this.instrument, other.instrument) &&
            Objects.deepEquals(this.strictBuiltinErrors, other.strictBuiltinErrors) &&
            Objects.deepEquals(this.requestBody, other.requestBody);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            path,
            contentEncoding,
            acceptEncoding,
            pretty,
            provenance,
            explain,
            metrics,
            instrument,
            strictBuiltinErrors,
            requestBody);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ExecuteBatchPolicyWithInputRequest.class,
                "path", path,
                "contentEncoding", contentEncoding,
                "acceptEncoding", acceptEncoding,
                "pretty", pretty,
                "provenance", provenance,
                "explain", explain,
                "metrics", metrics,
                "instrument", instrument,
                "strictBuiltinErrors", strictBuiltinErrors,
                "requestBody", requestBody);
    }
    
    public final static class Builder {
 
        private String path;
 
        private Optional<? extends GzipContentEncoding> contentEncoding = Optional.empty();
 
        private Optional<? extends GzipAcceptEncoding> acceptEncoding = Optional.empty();
 
        private Optional<Boolean> pretty = Optional.empty();
 
        private Optional<Boolean> provenance = Optional.empty();
 
        private Optional<? extends Explain> explain = Optional.empty();
 
        private Optional<Boolean> metrics = Optional.empty();
 
        private Optional<Boolean> instrument = Optional.empty();
 
        private Optional<Boolean> strictBuiltinErrors = Optional.empty();
 
        private ExecuteBatchPolicyWithInputRequestBody requestBody;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The path separator is used to access values inside object and array documents. If the path indexes into an array, the server will attempt to convert the array index to an integer. If the path element cannot be converted to an integer, the server will respond with 404.
         */
        public Builder path(String path) {
            Utils.checkNotNull(path, "path");
            this.path = path;
            return this;
        }

        /**
         * Indicates that the request body is gzip encoded
         */
        public Builder contentEncoding(GzipContentEncoding contentEncoding) {
            Utils.checkNotNull(contentEncoding, "contentEncoding");
            this.contentEncoding = Optional.ofNullable(contentEncoding);
            return this;
        }

        /**
         * Indicates that the request body is gzip encoded
         */
        public Builder contentEncoding(Optional<? extends GzipContentEncoding> contentEncoding) {
            Utils.checkNotNull(contentEncoding, "contentEncoding");
            this.contentEncoding = contentEncoding;
            return this;
        }

        /**
         * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
         */
        public Builder acceptEncoding(GzipAcceptEncoding acceptEncoding) {
            Utils.checkNotNull(acceptEncoding, "acceptEncoding");
            this.acceptEncoding = Optional.ofNullable(acceptEncoding);
            return this;
        }

        /**
         * Indicates the server should respond with a gzip encoded body. The server will send the compressed response only if its length is above `server.encoding.gzip.min_length` value. See the configuration section
         */
        public Builder acceptEncoding(Optional<? extends GzipAcceptEncoding> acceptEncoding) {
            Utils.checkNotNull(acceptEncoding, "acceptEncoding");
            this.acceptEncoding = acceptEncoding;
            return this;
        }

        /**
         * If parameter is `true`, response will formatted for humans.
         */
        public Builder pretty(boolean pretty) {
            Utils.checkNotNull(pretty, "pretty");
            this.pretty = Optional.ofNullable(pretty);
            return this;
        }

        /**
         * If parameter is `true`, response will formatted for humans.
         */
        public Builder pretty(Optional<Boolean> pretty) {
            Utils.checkNotNull(pretty, "pretty");
            this.pretty = pretty;
            return this;
        }

        /**
         * If parameter is true, response will include build/version info in addition to the result.
         */
        public Builder provenance(boolean provenance) {
            Utils.checkNotNull(provenance, "provenance");
            this.provenance = Optional.ofNullable(provenance);
            return this;
        }

        /**
         * If parameter is true, response will include build/version info in addition to the result.
         */
        public Builder provenance(Optional<Boolean> provenance) {
            Utils.checkNotNull(provenance, "provenance");
            this.provenance = provenance;
            return this;
        }

        /**
         * Return query explanation in addition to result.
         */
        public Builder explain(Explain explain) {
            Utils.checkNotNull(explain, "explain");
            this.explain = Optional.ofNullable(explain);
            return this;
        }

        /**
         * Return query explanation in addition to result.
         */
        public Builder explain(Optional<? extends Explain> explain) {
            Utils.checkNotNull(explain, "explain");
            this.explain = explain;
            return this;
        }

        /**
         * Return query performance metrics in addition to result.
         */
        public Builder metrics(boolean metrics) {
            Utils.checkNotNull(metrics, "metrics");
            this.metrics = Optional.ofNullable(metrics);
            return this;
        }

        /**
         * Return query performance metrics in addition to result.
         */
        public Builder metrics(Optional<Boolean> metrics) {
            Utils.checkNotNull(metrics, "metrics");
            this.metrics = metrics;
            return this;
        }

        /**
         * Instrument query evaluation and return a superset of performance metrics in addition to result.
         */
        public Builder instrument(boolean instrument) {
            Utils.checkNotNull(instrument, "instrument");
            this.instrument = Optional.ofNullable(instrument);
            return this;
        }

        /**
         * Instrument query evaluation and return a superset of performance metrics in addition to result.
         */
        public Builder instrument(Optional<Boolean> instrument) {
            Utils.checkNotNull(instrument, "instrument");
            this.instrument = instrument;
            return this;
        }

        /**
         * Treat built-in function call errors as fatal and return an error immediately.
         */
        public Builder strictBuiltinErrors(boolean strictBuiltinErrors) {
            Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
            this.strictBuiltinErrors = Optional.ofNullable(strictBuiltinErrors);
            return this;
        }

        /**
         * Treat built-in function call errors as fatal and return an error immediately.
         */
        public Builder strictBuiltinErrors(Optional<Boolean> strictBuiltinErrors) {
            Utils.checkNotNull(strictBuiltinErrors, "strictBuiltinErrors");
            this.strictBuiltinErrors = strictBuiltinErrors;
            return this;
        }

        /**
         * The batch of inputs
         */
        public Builder requestBody(ExecuteBatchPolicyWithInputRequestBody requestBody) {
            Utils.checkNotNull(requestBody, "requestBody");
            this.requestBody = requestBody;
            return this;
        }
        
        public ExecuteBatchPolicyWithInputRequest build() {
            if (path == null) {
                path = _SINGLETON_VALUE_Path.value();
            }            return new ExecuteBatchPolicyWithInputRequest(
                path,
                contentEncoding,
                acceptEncoding,
                pretty,
                provenance,
                explain,
                metrics,
                instrument,
                strictBuiltinErrors,
                requestBody);
        }

        private static final LazySingletonValue<String> _SINGLETON_VALUE_Path =
                new LazySingletonValue<>(
                        "path",
                        "\"\"",
                        new TypeReference<String>() {});
    }
}

